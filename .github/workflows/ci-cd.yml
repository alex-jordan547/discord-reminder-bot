name: CI/CD Pipeline

on:
  push:
    branches: ['**'] # Tous les push d√©clenchent les tests
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
  pull_request:
    branches: [main, preprod]
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      skip_tests:
        description: 'Skip tests (not recommended)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # üîÑ TESTS - Se lancent sur TOUS les push et PR
  test:
    name: Tests & Quality
    runs-on: ubuntu-latest
    timeout-minutes: 20
    # Se lance toujours sauf si explicitement d√©sactiv√©
    if: ${{ !inputs.skip_tests }}

    strategy:
      fail-fast: false
      matrix:
        node-version: [20, 22]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'yarn'

      - name: Install dependencies
        run: |
          yarn install --frozen-lockfile

      - name: Code formatting
        run: |
          # Auto-fix formatting with Prettier
          yarn format

          # Check if any files were changed by formatting
          if ! git diff --exit-code; then
            echo "‚ö†Ô∏è Code formatting issues detected and fixed"
            echo "Files modified by Prettier:"
            git diff --name-only
            # In CI, we could either fail or auto-commit the fixes
            # For now, we'll continue but show the diff
          else
            echo "‚úÖ Code formatting is correct"
          fi

      - name: Code quality checks
        run: |
          # Linting avec ESLint (non-strict pour le moment)
          yarn lint || echo "‚ö†Ô∏è Linting issues found but continuing..."

          # Type checking avec TypeScript (non-strict pour le moment)
          yarn type-check || echo "‚ö†Ô∏è Type checking issues found but continuing..."
        continue-on-error: true

      - name: Security checks
        run: |
          # Audit des d√©pendances Yarn
          yarn audit --level moderate || echo "‚ö†Ô∏è Security audit found issues but continuing..."
        continue-on-error: true

      - name: Unit tests
        env:
          DISCORD_TOKEN: test-token-for-ci
        run: |
          # Tests avec Vitest et coverage
          yarn test:coverage

      - name: Upload coverage to Codecov
        if: matrix.node-version == 20
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          file: ./coverage/lcov.info
          fail_ci_if_error: false

    outputs:
      test-success: ${{ steps.unit-tests.outcome == 'success' }}

  # üèóÔ∏è BUILD - Se lance uniquement pour PR, tags et main
  build:
    name: Build & Package
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: test
    # Conditions : PR vers main/preprod, push vers main/preprod, tags, ou manuel
    if: |
      github.event_name == 'pull_request' ||
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/preprod')) ||
      github.event_name == 'release' ||
      github.event_name == 'workflow_dispatch'

    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write

    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
      version: ${{ steps.meta.outputs.version }}
      tags: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value={{branch}}-{{date 'YYYY-MM-DD'}}
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
          labels: |
            org.opencontainers.image.title=Discord Reminder Bot
            org.opencontainers.image.description=Bot Discord pour la gestion des rappels d'√©v√©nements
            org.opencontainers.image.url=https://github.com/${{ github.repository }}
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.vendor=${{ github.repository_owner }}
            org.opencontainers.image.created={{date 'iso8601'}}
            org.opencontainers.image.revision=${{ github.sha }}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          provenance: mode=max
          sbom: true

      - name: Generate attestation
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.build.outputs.digest }}
          push-to-registry: true

      - name: Security scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: Upload security scan results
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true

      - name: Output image info
        id: image
        run: |
          echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Create deployment package
        run: |
          mkdir -p deployment-package
          cp docker-compose.yml deployment-package/
          cp .env.example deployment-package/env.template

          # Script de d√©ploiement intelligent
          cat > deployment-package/deploy.sh << 'EOF'
          #!/bin/bash
          set -e

          IMAGE_NAME="${1:-${{ steps.image.outputs.image }}}"
          DIGEST="${{ steps.build.outputs.digest }}"

          echo "üöÄ D√©ploiement Discord Reminder Bot"
          echo "üì¶ Image: $IMAGE_NAME"
          echo "üîç Digest: $DIGEST"

          # Arr√™t en douceur
          echo "üõë Arr√™t du conteneur existant..."
          docker compose down --timeout 30 || true

          # Sauvegarde des donn√©es SQLite et logs
          echo "üíæ Sauvegarde des donn√©es..."
          if [ -f "discord_bot.db" ]; then
            cp discord_bot.db "backup_$(date +%Y%m%d_%H%M%S).db"
          fi
          if [ -d "logs" ]; then
            tar -czf "logs_backup_$(date +%Y%m%d_%H%M%S).tar.gz" logs/
          fi

          # T√©l√©chargement de l'image
          echo "üì• T√©l√©chargement de l'image..."
          docker pull "$IMAGE_NAME"

          # V√©rification du digest
          if [ -n "$DIGEST" ]; then
            PULLED_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE_NAME" | cut -d'@' -f2)
            if [ "$PULLED_DIGEST" != "$DIGEST" ]; then
              echo "‚ö†Ô∏è  Attention: Digest diff√©rent (attendu: $DIGEST, re√ßu: $PULLED_DIGEST)"
            fi
          fi

          # Variables d'environnement
          export IMAGE_NAME="$IMAGE_NAME"

          # D√©marrage
          echo "‚ñ∂Ô∏è  D√©marrage du nouveau conteneur..."
          docker compose up -d

          # V√©rification
          echo "üîç V√©rification du statut..."
          sleep 15

          for i in {1..5}; do
            if docker compose ps discord-reminder-bot | grep -q "Up"; then
              echo "‚úÖ Conteneur d√©marr√© avec succ√®s"
              break
            elif [ $i -eq 5 ]; then
              echo "‚ùå √âchec du d√©marrage"
              docker compose logs --tail=50 discord-reminder-bot
              exit 1
            else
              echo "‚è≥ Tentative $i/5..."
              sleep 10
            fi
          done

          echo "üéâ D√©ploiement r√©ussi!"
          docker compose logs --tail=10 discord-reminder-bot
          EOF

          chmod +x deployment-package/deploy.sh

          # Script de rollback
          cat > deployment-package/rollback.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "üîÑ Rollback Discord Reminder Bot"

          docker compose down

          # Restauration de la derni√®re sauvegarde DB
          LATEST_DB_BACKUP=$(ls -t backup_*.db 2>/dev/null | head -n1 || echo "")
          if [ -n "$LATEST_DB_BACKUP" ]; then
            echo "üíæ Restauration DB depuis $LATEST_DB_BACKUP"
            cp "$LATEST_DB_BACKUP" discord_bot.db
          fi

          echo "‚ö†Ô∏è  Veuillez sp√©cifier manuellement l'image pr√©c√©dente"
          echo "Exemple: IMAGE_NAME=previous-image ./deploy.sh"
          EOF

          chmod +x deployment-package/rollback.sh

      - name: Upload deployment package
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package-${{ github.sha }}
          path: deployment-package/
          retention-days: 90

      - name: Build summary
        run: |
          echo "## üèóÔ∏è Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ steps.image.outputs.image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Digest**: \`${{ steps.build.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Tags**: \`${{ steps.meta.outputs.tags }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Platforms**: \`linux/amd64, linux/arm64\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Security**: Trivy scan completed" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Package**: Ready for deployment" >> $GITHUB_STEP_SUMMARY

  # üöÄ DEPLOY STAGING - Utilise l'artefact du build
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [test, build]
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/preprod') ||
      (github.event_name == 'workflow_dispatch' && inputs.environment == 'staging')
    environment: staging
    steps:
      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: deployment-package-${{ github.sha }}
          path: deployment/

      - name: Deploy to staging
        run: |
          echo "üîÑ D√©ploiement en staging"
          echo "üì¶ Image: ${{ needs.build.outputs.image }}"
          echo "üîç Digest: ${{ needs.build.outputs.digest }}"

          # Ici vous ajouteriez votre logique de d√©ploiement staging
          # Exemple:
          # scp -r deployment/ staging-server:/opt/discord-bot/
          # ssh staging-server "cd /opt/discord-bot && ./deploy.sh ${{ needs.build.outputs.image }}"

          echo "‚úÖ D√©ploiement staging simul√©"

      - name: Health check staging
        run: |
          echo "üîç V√©rification de sant√© staging..."
          # Ajoutez ici vos tests de sant√©
          echo "‚úÖ Staging op√©rationnel"

  # üöÄ DEPLOY PRODUCTION - Utilise l'artefact du build
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [test, build]
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      github.event_name == 'release' ||
      (github.event_name == 'workflow_dispatch' && inputs.environment == 'production')
    environment: production
    steps:
      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: deployment-package-${{ github.sha }}
          path: deployment/

      - name: Deploy to production
        run: |
          echo "üöÄ D√©ploiement en production"
          echo "üì¶ Image: ${{ needs.build.outputs.image }}"
          echo "üîç Digest: ${{ needs.build.outputs.digest }}"

          # Configuration SSH et d√©ploiement r√©el
          # echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          # chmod 600 ~/.ssh/id_rsa
          # ssh-keyscan -H your-server.com >> ~/.ssh/known_hosts
          # scp -r deployment/ user@your-server:/opt/discord-bot/
          # ssh user@your-server "cd /opt/discord-bot && ./deploy.sh ${{ needs.build.outputs.image }}"

          echo "‚úÖ Package de d√©ploiement production pr√™t"

      - name: Production health check
        run: |
          echo "üîç V√©rification de sant√© production..."
          # Tests de sant√© production
          echo "‚úÖ Production op√©rationnelle"

      - name: Create deployment record
        run: |
          echo "## üéâ Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Completed" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ needs.build.outputs.image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Digest**: \`${{ needs.build.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed at**: $(date -u)" >> $GITHUB_STEP_SUMMARY

  # üìä NOTIFICATION - Synth√®se finale
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [test, build, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result != 'skipped' || needs.deploy-production.result != 'skipped')

    steps:
      - name: Determine status
        id: status
        run: |
          if [[ "${{ needs.deploy-production.result }}" == "success" || "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "environment=${{ needs.deploy-production.result == 'success' && 'production' || 'staging' }}" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "environment=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Success notification
        if: steps.status.outputs.status == 'success'
        run: |
          echo "‚úÖ D√©ploiement ${{ steps.status.outputs.environment }} r√©ussi!"
          echo "üöÄ Image: ${{ needs.build.outputs.image }}"
          echo "üîó Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Notification Discord/Slack optionnelle
          # curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
          #   -H "Content-Type: application/json" \
          #   -d "{\"content\": \"‚úÖ Bot d√©ploy√© en ${{ steps.status.outputs.environment }}!\nüì¶ Image: \`${{ needs.build.outputs.image }}\`\"}"

      - name: Failure notification
        if: steps.status.outputs.status == 'failure'
        run: |
          echo "‚ùå √âchec du d√©ploiement!"
          echo "üîó Logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Notification d'√©chec
          # curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
          #   -H "Content-Type: application/json" \
          #   -d "{\"content\": \"‚ùå √âchec du d√©ploiement!\nüîó D√©tails: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}"

      - name: Final summary
        run: |
          echo "## üìä Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests**: ${{ needs.test.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build**: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Staging**: ${{ needs.deploy-staging.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Production**: ${{ needs.deploy-production.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Overall Status**: ${{ steps.status.outputs.status }}" >> $GITHUB_STEP_SUMMARY
