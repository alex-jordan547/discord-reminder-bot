/**
 * Discord Reminder Bot - Reminder Scheduler Service
 * 
 * Advanced scheduling system that provides:
 * - Dynamic scheduling based on next reminder time
 * - Smart sleep mode when no events are active
 * - Precise timing with Â±5 second accuracy
 * - Automatic rescheduling after reminders
 */

import { Client, TextChannel, EmbedBuilder, User } from 'discord.js';\nimport { createLogger } from '@/utils/loggingConfig';\nimport { EventManager } from './eventManager';\nimport { Event } from '@/models/Event';\nimport { Settings } from '@/config/settings';\n\nconst logger = createLogger('reminder-scheduler');\n\n/**\n * Scheduler status information\n */\nexport interface SchedulerStatus {\n  status: 'active' | 'sleeping' | 'stopped' | 'error';\n  nextCheck: Date | null;\n  activeEvents: number;\n  lastReminderSent: Date | null;\n}\n\n/**\n * Reminder Scheduler Service Class\n * \n * Manages the intelligent scheduling of reminder checks and sending.\n * Uses dynamic timing to minimize resource usage while maintaining precision.\n */\nexport class ReminderScheduler {\n  private client: Client;\n  private eventManager: EventManager;\n  private scheduledTimeout: NodeJS.Timeout | null = null;\n  private isRunning: boolean = false;\n  private status: SchedulerStatus;\n\n  constructor(client: Client, eventManager: EventManager) {\n    this.client = client;\n    this.eventManager = eventManager;\n    this.status = {\n      status: 'stopped',\n      nextCheck: null,\n      activeEvents: 0,\n      lastReminderSent: null,\n    };\n  }\n\n  /**\n   * Initialize and start the reminder scheduler\n   */\n  async initialize(): Promise<void> {\n    try {\n      logger.info('Initializing reminder scheduler...');\n      \n      this.isRunning = true;\n      this.status.status = 'active';\n      \n      // Schedule the first check\n      await this.scheduleNextCheck();\n      \n      logger.info('Reminder scheduler initialized and running');\n    } catch (error) {\n      logger.error(`Failed to initialize reminder scheduler: ${error}`);\n      this.status.status = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Stop the reminder scheduler\n   */\n  stop(): void {\n    logger.info('Stopping reminder scheduler...');\n    \n    this.isRunning = false;\n    this.status.status = 'stopped';\n    this.status.nextCheck = null;\n    \n    if (this.scheduledTimeout) {\n      clearTimeout(this.scheduledTimeout);\n      this.scheduledTimeout = null;\n    }\n    \n    logger.info('Reminder scheduler stopped');\n  }\n\n  /**\n   * Schedule a specific event (called when new events are created)\n   */\n  async scheduleEvent(event: Event): Promise<void> {\n    try {\n      logger.info(`Scheduling reminders for event ${event.messageId}`);\n      \n      // If scheduler is not running, start it\n      if (!this.isRunning) {\n        await this.initialize();\n      } else {\n        // Reschedule to check for this new event\n        await this.scheduleNextCheck();\n      }\n    } catch (error) {\n      logger.error(`Failed to schedule event ${event.messageId}: ${error}`);\n    }\n  }\n\n  /**\n   * Unschedule a specific event (called when events are removed)\n   */\n  async unscheduleEvent(messageId: string): Promise<void> {\n    try {\n      logger.info(`Unscheduling event ${messageId}`);\n      \n      // Reschedule to account for removed event\n      await this.scheduleNextCheck();\n    } catch (error) {\n      logger.error(`Failed to unschedule event ${messageId}: ${error}`);\n    }\n  }\n\n  /**\n   * Schedule the next reminder check using dynamic timing\n   */\n  private async scheduleNextCheck(): Promise<void> {\n    try {\n      // Clear existing timeout\n      if (this.scheduledTimeout) {\n        clearTimeout(this.scheduledTimeout);\n        this.scheduledTimeout = null;\n      }\n\n      if (!this.isRunning) {\n        return;\n      }\n\n      // Get next reminder time\n      const nextReminderTime = await this.eventManager.getNextReminderTime();\n      \n      if (!nextReminderTime) {\n        // No events to watch, enter sleep mode\n        this.enterSleepMode();\n        return;\n      }\n\n      const now = new Date();\n      const timeUntilNext = nextReminderTime.getTime() - now.getTime();\n      \n      // Ensure minimum delay to prevent excessive CPU usage\n      const delay = Math.max(timeUntilNext, 5000); // Minimum 5 seconds\n      \n      this.status.nextCheck = new Date(now.getTime() + delay);\n      this.status.status = 'active';\n      \n      logger.debug(`Next reminder check scheduled for ${this.status.nextCheck.toISOString()} (${Math.round(delay / 1000)}s from now)`);\n      \n      this.scheduledTimeout = setTimeout(() => {\n        this.checkReminders().catch(error => {\n          logger.error(`Error in scheduled reminder check: ${error}`);\n          // Reschedule after error\n          setTimeout(() => this.scheduleNextCheck(), 30000); // 30 second delay after error\n        });\n      }, delay);\n      \n    } catch (error) {\n      logger.error(`Failed to schedule next check: ${error}`);\n      this.status.status = 'error';\n      \n      // Try to recover by scheduling a check in 1 minute\n      setTimeout(() => this.scheduleNextCheck(), 60000);\n    }\n  }\n\n  /**\n   * Enter sleep mode when no events need watching\n   */\n  private enterSleepMode(): void {\n    this.status.status = 'sleeping';\n    this.status.nextCheck = null;\n    this.status.activeEvents = 0;\n    \n    logger.info('ðŸ›Œ Entering sleep mode - no events to watch');\n  }\n\n  /**\n   * Check for reminders that are due and send them\n   */\n  private async checkReminders(): Promise<void> {\n    try {\n      logger.debug('Checking for due reminders...');\n      \n      const eventsNeedingReminders = await this.eventManager.getEventsNeedingReminders();\n      \n      if (eventsNeedingReminders.length === 0) {\n        logger.debug('No reminders due at this time');\n      } else {\n        logger.info(`Sending ${eventsNeedingReminders.length} reminder(s)`);\n        \n        // Send reminders with delays between them\n        for (let i = 0; i < eventsNeedingReminders.length; i++) {\n          const event = eventsNeedingReminders[i];\n          \n          try {\n            await this.sendReminder(event);\n            await this.eventManager.markEventReminded(event.messageId);\n            \n            // Add delay between reminders to respect rate limits\n            if (i < eventsNeedingReminders.length - 1) {\n              await this.sleep(Settings.DELAY_BETWEEN_REMINDERS || 2000);\n            }\n          } catch (error) {\n            logger.error(`Failed to send reminder for event ${event.messageId}: ${error}`);\n          }\n        }\n        \n        this.status.lastReminderSent = new Date();\n      }\n      \n      // Update active events count\n      const activeEvents = await this.eventManager.getActiveEvents();\n      this.status.activeEvents = activeEvents.length;\n      \n      // Schedule next check\n      await this.scheduleNextCheck();\n      \n    } catch (error) {\n      logger.error(`Error during reminder check: ${error}`);\n      this.status.status = 'error';\n      \n      // Try to recover\n      setTimeout(() => this.scheduleNextCheck(), 30000);\n    }\n  }\n\n  /**\n   * Send a reminder for a specific event\n   */\n  private async sendReminder(event: Event): Promise<void> {\n    try {\n      // Get the channel\n      const channel = await this.client.channels.fetch(event.channelId) as TextChannel;\n      if (!channel) {\n        logger.warn(`Could not find channel ${event.channelId} for event ${event.messageId}`);\n        return;\n      }\n\n      // Check if bot has permissions\n      const permissions = channel.permissionsFor(this.client.user!);\n      if (!permissions?.has(['ViewChannel', 'SendMessages'])) {\n        logger.warn(`No permission to send reminders in channel ${event.channelId}`);\n        return;\n      }\n\n      // Get the original message for context\n      let originalMessage;\n      try {\n        originalMessage = await channel.messages.fetch(event.messageId);\n      } catch (error) {\n        logger.warn(`Could not fetch original message ${event.messageId}: ${error}`);\n      }\n\n      // Determine users to mention\n      const usersToMention = await this.getUsersToMention(event, originalMessage);\n      \n      if (usersToMention.length === 0) {\n        logger.info(`No users to mention for event ${event.messageId} - all have reacted`);\n        return;\n      }\n\n      // Create reminder embed\n      const embed = new EmbedBuilder()\n        .setColor(0xFFAA00)\n        .setTitle('ðŸ”” Event Reminder')\n        .setDescription(`Don't forget to react to this event if you're interested!`)\n        .addFields(\n          { name: 'ðŸ“ Event', value: event.title, inline: false },\n          { name: 'ðŸ‘¥ Waiting for', value: `${usersToMention.length} user(s)`, inline: true },\n          { name: 'âœ… Responded', value: `${event.usersWhoReacted.length} user(s)`, inline: true }\n        )\n        .setFooter({ text: 'React to the original message to stop getting reminders' })\n        .setTimestamp();\n\n      // Add link to original message if available\n      if (originalMessage) {\n        embed.addFields({\n          name: 'ðŸ”— Original Message',\n          value: `[Click here to jump to the event](https://discord.com/channels/${event.guildId}/${event.channelId}/${event.messageId})`,\n          inline: false\n        });\n      }\n\n      // Create mention string (limit to avoid spam)\n      const maxMentions = Settings.MAX_MENTIONS_PER_REMINDER || 50;\n      const mentionsToSend = usersToMention.slice(0, maxMentions);\n      const mentionString = mentionsToSend.map(id => `<@${id}>`).join(' ');\n      \n      // Send the reminder\n      const reminderMessage = await channel.send({\n        content: mentionString,\n        embeds: [embed],\n        allowedMentions: {\n          users: mentionsToSend,\n          repliedUser: false,\n        },\n      });\n\n      // If there were more users than the mention limit, send a follow-up\n      if (usersToMention.length > maxMentions) {\n        const remainingCount = usersToMention.length - maxMentions;\n        await channel.send({\n          content: `âš ï¸ ${remainingCount} additional user(s) also need to respond to this event.`,\n          reply: { messageReference: reminderMessage.id, failIfNotExists: false },\n        });\n      }\n\n      logger.info(`Sent reminder for event ${event.messageId} to ${mentionsToSend.length} users`);\n\n      // Auto-delete reminder if configured\n      if (Settings.AUTO_DELETE_REMINDERS && Settings.AUTO_DELETE_DELAY_HOURS > 0) {\n        const deleteDelay = Settings.AUTO_DELETE_DELAY_HOURS * 60 * 60 * 1000;\n        setTimeout(() => {\n          reminderMessage.delete().catch(error => {\n            logger.debug(`Could not auto-delete reminder: ${error}`);\n          });\n        }, deleteDelay);\n      }\n\n    } catch (error) {\n      logger.error(`Error sending reminder for event ${event.messageId}: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Get users that should be mentioned in the reminder\n   */\n  private async getUsersToMention(event: Event, originalMessage: any): Promise<string[]> {\n    try {\n      if (!originalMessage) {\n        // Can't determine who to mention without the original message\n        return [];\n      }\n\n      // Get all members in the guild\n      const guild = originalMessage.guild;\n      if (!guild) {\n        return [];\n      }\n\n      // Fetch guild members if not cached\n      await guild.members.fetch();\n      \n      // Get all non-bot members\n      const allMembers = guild.members.cache\n        .filter(member => !member.user.bot)\n        .map(member => member.user.id);\n      \n      // Filter out users who have already reacted\n      const usersToMention = allMembers.filter(userId => \n        !event.usersWhoReacted.includes(userId)\n      );\n      \n      return usersToMention;\n    } catch (error) {\n      logger.error(`Error determining users to mention: ${error}`);\n      return [];\n    }\n  }\n\n  /**\n   * Get current scheduler status\n   */\n  getStatus(): SchedulerStatus {\n    return { ...this.status };\n  }\n\n  /**\n   * Utility function for adding delays\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Force an immediate reminder check (for testing/debugging)\n   */\n  async forceCheck(): Promise<void> {\n    if (!this.isRunning) {\n      throw new Error('Scheduler is not running');\n    }\n    \n    logger.info('Forcing immediate reminder check');\n    await this.checkReminders();\n  }\n\n  /**\n   * Get statistics about the scheduler\n   */\n  async getStatistics(): Promise<{\n    totalEvents: number;\n    activeEvents: number;\n    nextReminderIn: number | null;\n    lastReminderSent: Date | null;\n    status: string;\n  }> {\n    try {\n      const totalEvents = await this.eventManager.getTotalEventCount();\n      const activeEvents = await this.eventManager.getActiveEvents();\n      const nextReminderTime = await this.eventManager.getNextReminderTime();\n      \n      const nextReminderIn = nextReminderTime \n        ? nextReminderTime.getTime() - Date.now()\n        : null;\n      \n      return {\n        totalEvents,\n        activeEvents: activeEvents.length,\n        nextReminderIn,\n        lastReminderSent: this.status.lastReminderSent,\n        status: this.status.status,\n      };\n    } catch (error) {\n      logger.error(`Error getting scheduler statistics: ${error}`);\n      throw error;\n    }\n  }\n}