"""
Tests fonctionnels end-to-end pour le Discord Reminder Bot.

Ces tests simulent des sc√©narios utilisateur complets et r√©alistes,
couvrant les cas d'usage typiques, la gestion d'erreurs, les interactions
multi-utilisateurs et les sc√©narios de charge.

Conforme √† la t√¢che 5.1 : Tests de sc√©narios utilisateur complets.
"""

import asyncio
import json
import logging
import os
import random
import tempfile
from datetime import datetime, timedelta
from typing import Any, Dict, List, Tuple
from unittest.mock import AsyncMock, MagicMock, Mock, patch

import pytest

logger = logging.getLogger(__name__)


class TestTypicalUserScenarios:
    """Tests des sc√©narios d'usage typiques du bot."""

    @pytest.mark.functional
    @pytest.mark.asyncio
    async def test_complete_reminder_lifecycle(self, working_database, fixture_manager, discord_mock_manager):
        """
        Test du cycle de vie complet d'un rappel.
        
        Sc√©nario : Un utilisateur cr√©e un rappel, re√ßoit des notifications,
        et g√®re les r√©actions des participants.
        """
        # 1. Pr√©parer l'environnement
        guild, users = fixture_manager.create_guild_with_users(
            user_count=5, name="Gaming Guild", member_count=50
        )
        admin_user = users[0]
        participants = users[1:]

        # Cr√©er les mocks Discord
        mock_bot = discord_mock_manager.create_bot_mock()
        mock_guild = discord_mock_manager.create_guild_mock(id=guild.guild_id, name=guild.name)
        mock_channel = discord_mock_manager.create_channel_mock(
            id=300000000000000001, guild=mock_guild, name="events"
        )
        mock_message = discord_mock_manager.create_message_mock(
            id=400000000000000001,
            channel=mock_channel,
            author=discord_mock_manager.create_user_mock(id=admin_user.user_id),
            content="üéÆ Match CS:GO ce soir √† 20h ! Qui est partant ?",
        )

        # 2. Cr√©er un √©v√©nement via le gestionnaire de rappels
        from utils.event_manager_adapter import event_manager_adapter as reminder_manager

        # Cr√©er un Event directement
        event = fixture_manager.create_event(
            guild=guild,
            title="Match CS:GO",
            interval_minutes=120,  # 2 heures
            message_id=400000000000000001,
            channel_id=300000000000000001,
        )

        # 3. Simuler les r√©actions des utilisateurs
        from datetime import timedelta
        
        mock_reactions = []
        for i, user in enumerate(participants):
            emoji = "‚úÖ" if i < 3 else "‚ùå"  # 3 participants positifs, 1 n√©gatif
            reaction = fixture_manager.create_reaction(
                event=event,
                user=user,
                emoji=emoji,
                added_at=datetime.now() - timedelta(minutes=random.randint(1, 30)),
            )
            mock_reactions.append(reaction)

        # 4. Tester la logique de rappel - simuler qu'il est temps d'envoyer un rappel
        event.last_reminder = datetime.now() - timedelta(hours=3)
        event.save()

        # V√©rifier que l'√©v√©nement est consid√©r√© comme n√©cessitant un rappel
        assert event.is_due_for_reminder, "L'√©v√©nement devrait n√©cessiter un rappel"

        # Ajouter l'√©v√©nement au gestionnaire de rappels pour les tests de pause/reprise
        add_success = await reminder_manager.add_reminder(event)
        assert add_success, "L'ajout de l'√©v√©nement au gestionnaire doit r√©ussir"

        # 5. Tester la pause et reprise
        # Mettre en pause
        pause_success = await reminder_manager.pause_reminder(event.message_id)
        assert pause_success, "La pause doit r√©ussir"

        # Recharger l'√©v√©nement depuis la base de donn√©es
        event_paused = await reminder_manager.get_reminder(event.message_id)
        if event_paused is None:
            # Fallback : recharger depuis la base de donn√©es directement
            from models.database_models import Event
            event_paused = Event.get_by_id(event.id)
        assert event_paused.is_paused, "L'√©v√©nement doit √™tre en pause"

        # Reprendre
        resume_success = await reminder_manager.resume_reminder(event.message_id)
        assert resume_success, "La reprise doit r√©ussir"

        # Recharger l'√©v√©nement
        event_resumed = await reminder_manager.get_reminder(event.message_id)
        if event_resumed is None:
            # Fallback : recharger depuis la base de donn√©es directement
            from models.database_models import Event
            event_resumed = Event.get_by_id(event.id)
        assert not event_resumed.is_paused, "L'√©v√©nement ne doit plus √™tre en pause"

    @pytest.mark.functional
    @pytest.mark.asyncio
    async def test_multi_guild_independence(self, working_database, fixture_manager, discord_mock_manager):
        """
        Test de l'ind√©pendance entre plusieurs guilds.
        
        Sc√©nario : Plusieurs guilds utilisent le bot simultan√©ment
        sans interf√©rence mutuelle.
        """
        # Cr√©er 3 guilds diff√©rents
        guilds_data = []
        for i in range(3):
            guild, users = fixture_manager.create_guild_with_users(
                user_count=3, name=f"Guild {i+1}", member_count=random.randint(20, 100)
            )
            guilds_data.append((guild, users))

        # Cr√©er des √©v√©nements dans chaque guild
        events = []
        for guild, users in guilds_data:
            event = fixture_manager.create_event(
                guild=guild,
                title=f"Event in {guild.name}",
                interval_minutes=60,
                message_id=fixture_manager.get_unique_id("message"),
                channel_id=fixture_manager.get_unique_id("channel"),
            )
            events.append(event)

            # Ajouter des r√©actions sp√©cifiques √† chaque guild
            for user in users:
                fixture_manager.create_reaction(
                    event=event, user=user, emoji="‚úÖ" if random.random() > 0.3 else "‚ùå"
                )

        # Ajouter les √©v√©nements au reminder manager pour qu'ils soient visibles par la commande list
        from utils.event_manager_adapter import event_manager_adapter as reminder_manager
        for event in events:
            await reminder_manager.add_reminder(event)

        # V√©rifier l'isolation des donn√©es
        from models.database_models import Event, Reaction

        for i, (guild, users) in enumerate(guilds_data):
            # V√©rifier que chaque guild ne voit que ses propres √©v√©nements
            guild_events = list(Event.select().where(Event.guild == guild))
            assert len(guild_events) == 1
            assert guild_events[0].title == f"Event in {guild.name}"

            # V√©rifier que les r√©actions sont isol√©es par guild
            guild_reactions = list(
                Reaction.select().join(Event).where(Event.guild == guild)
            )
            assert len(guild_reactions) == len(users)

            # V√©rifier que chaque r√©action a un utilisateur associ√©
            for reaction in guild_reactions:
                assert hasattr(reaction, 'user_id'), "La r√©action devrait avoir un user_id"

        # Tester les commandes avec isolation
        mock_bot = discord_mock_manager.create_bot_mock()
        from commands.slash_commands import SlashCommands

        slash_commands = SlashCommands(mock_bot)

        for guild, users in guilds_data:
            mock_guild = discord_mock_manager.create_guild_mock(
                id=guild.guild_id, name=guild.name
            )
            mock_interaction = Mock()
            mock_interaction.response = AsyncMock()
            mock_interaction.followup = AsyncMock()
            mock_interaction.guild = mock_guild
            mock_interaction.user = discord_mock_manager.create_user_mock(id=users[0].user_id)

            # Lister les √©v√©nements - chaque guild ne doit voir que les siens
            await slash_commands.list_events.callback(slash_commands, mock_interaction)

            # V√©rifier que la r√©ponse ne contient que les √©v√©nements du guild
            mock_interaction.response.send_message.assert_called()
            call_args = mock_interaction.response.send_message.call_args
            # La r√©ponse peut √™tre dans un embed ou dans le message direct
            response_content = str(call_args)
            
            # Si la r√©ponse contient un embed, extraire son contenu
            if "embed=" in response_content:
                # Pour simplifier, v√©rifions que la r√©ponse ne contient pas les √©v√©nements des autres guilds
                # et qu'elle ne dit pas "Aucun √©v√©nement"
                assert "Aucun √©v√©nement" not in response_content, f"Aucun √©v√©nement trouv√© pour le guild {guild.name}"
            else:
                # V√©rifier que le titre de l'√©v√©nement est pr√©sent dans la r√©ponse
                assert f"Event in {guild.name}" in response_content, f"√âv√©nement du guild {guild.name} non trouv√© dans la r√©ponse: {response_content}"

    @pytest.mark.functional
    @pytest.mark.asyncio
    async def test_concurrent_user_interactions(self, working_database, fixture_manager, discord_mock_manager):
        """
        Test des interactions simultan√©es de plusieurs utilisateurs.
        
        Sc√©nario : Plusieurs utilisateurs interagissent simultan√©ment
        avec le bot sans conflit ni corruption de donn√©es.
        """
        # Pr√©parer l'environnement
        guild, users = fixture_manager.create_guild_with_users(
            user_count=10, name="Busy Guild", member_count=200
        )

        # Cr√©er un √©v√©nement de base
        event = fixture_manager.create_event(
            guild=guild,
            title="Concurrent Test Event",
            interval_minutes=30,
        )

        # Simuler des actions concurrentes
        mock_bot = discord_mock_manager.create_bot_mock()
        from commands.slash_commands import SlashCommands

        slash_commands = SlashCommands(mock_bot)

        async def user_action(user, action_type):
            """Simule une action utilisateur sp√©cifique."""
            mock_guild = discord_mock_manager.create_guild_mock(
                id=guild.guild_id, name=guild.name
            )
            mock_interaction = Mock()
            mock_interaction.response = AsyncMock()
            mock_interaction.followup = AsyncMock()
            mock_interaction.guild = mock_guild
            mock_interaction.user = discord_mock_manager.create_user_mock(id=user.user_id)

            try:
                if action_type == "list":
                    await slash_commands.list_events.callback(slash_commands, mock_interaction)
                elif action_type == "pause":
                    await slash_commands.pause.callback(slash_commands, mock_interaction, message=f"https://discord.com/channels/{guild.guild_id}/{event.channel_id}/{event.message_id}")
                elif action_type == "resume":
                    await slash_commands.resume.callback(slash_commands, mock_interaction, message=f"https://discord.com/channels/{guild.guild_id}/{event.channel_id}/{event.message_id}")
                elif action_type == "reaction":
                    # Simuler l'ajout d'une r√©action
                    fixture_manager.create_reaction(
                        event=event, user=user, emoji=random.choice(["‚úÖ", "‚ùå", "ü§î"])
                    )

                return True
            except Exception as e:
                logger.warning(f"User action failed: {e}")
                return False

        # Lancer des actions concurrentes
        tasks = []
        for i, user in enumerate(users):
            action_type = ["list", "reaction", "list", "reaction"][i % 4]
            task = asyncio.create_task(user_action(user, action_type))
            tasks.append(task)

        # Attendre que toutes les actions se terminent
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # V√©rifier que la plupart des actions ont r√©ussi
        successful_actions = sum(1 for r in results if r is True)
        assert successful_actions >= len(users) * 0.8  # Au moins 80% de succ√®s

        # V√©rifier l'int√©grit√© des donn√©es
        from models.database_models import Reaction

        reactions = list(Reaction.select().where(Reaction.event == event))
        # Il devrait y avoir des r√©actions mais pas de doublons par utilisateur
        user_reactions = {}
        for reaction in reactions:
            if reaction.user_id in user_reactions:
                # Pas de doublons exacts (m√™me utilisateur, m√™me emoji)
                existing = user_reactions[reaction.user_id]
                assert reaction.emoji != existing or reaction.added_at != existing
            user_reactions[reaction.user_id] = reaction.emoji

    @pytest.mark.functional
    @pytest.mark.asyncio
    async def test_error_handling_and_recovery(self, working_database, fixture_manager, discord_mock_manager):
        """
        Test de la gestion d'erreurs et de la r√©cup√©ration.
        
        Sc√©nario : Le bot rencontre diverses erreurs et doit
        les g√©rer gracieusement sans corrompre les donn√©es.
        """
        guild, users = fixture_manager.create_guild_with_users(user_count=3)
        admin_user = users[0]

        mock_bot = discord_mock_manager.create_bot_mock()
        from commands.slash_commands import SlashCommands

        slash_commands = SlashCommands(mock_bot)

        # Pr√©parer les mocks d'interaction
        mock_guild = discord_mock_manager.create_guild_mock(
            id=guild.guild_id, name=guild.name
        )
        mock_interaction = Mock()
        mock_interaction.response = AsyncMock()
        mock_interaction.followup = AsyncMock()
        mock_interaction.guild = mock_guild
        mock_interaction.user = discord_mock_manager.create_user_mock(id=admin_user.user_id)

        # Test 1: Lien de message invalide
        try:
            await slash_commands.watch.callback(
                slash_commands,
                interaction=mock_interaction,
                message="invalid_link",
                interval=3600,  # 1 heure en secondes
            )
            # La commande devrait g√©rer l'erreur gracieusement
            mock_interaction.response.send_message.assert_called()
            error_msg = str(mock_interaction.response.send_message.call_args)
            assert "erreur" in error_msg.lower() or "invalid" in error_msg.lower()
        except Exception:
            pytest.fail("La commande aurait d√ª g√©rer l'erreur gracieusement")

        # Test 2: Intervalle invalide
        try:
            await slash_commands.watch.callback(
                slash_commands,
                interaction=mock_interaction,
                message=f"https://discord.com/channels/{guild.guild_id}/123/456",
                interval=3600,  # 1 heure en secondes
                title="Test Event",
            )
            # V√©rifier que l'erreur est g√©r√©e
            assert mock_interaction.response.send_message.called
        except Exception:
            pytest.fail("La commande aurait d√ª g√©rer l'intervalle invalide")

        # Test 3: Op√©ration sur √©v√©nement inexistant
        try:
            await slash_commands.pause.callback(slash_commands, mock_interaction, message="https://discord.com/channels/123/456/999999999999999999")
            # Devrait retourner une erreur appropri√©e
            assert mock_interaction.response.send_message.called
        except Exception:
            pytest.fail("La commande aurait d√ª g√©rer l'√©v√©nement inexistant")

        # Test 4: Simuler une erreur de base de donn√©es
        event = fixture_manager.create_event(guild=guild, title="Test Event")

        with patch("models.database_models.Event.get") as mock_get:
            mock_get.side_effect = Exception("Database error")
            try:
                await slash_commands.pause.callback(slash_commands, mock_interaction, message=f"https://discord.com/channels/{guild.guild_id}/{event.channel_id}/{event.message_id}")
                # L'erreur devrait √™tre g√©r√©e
                assert True
            except Exception:
                pytest.fail("Les erreurs de base de donn√©es devraient √™tre g√©r√©es")

        # V√©rifier que les donn√©es ne sont pas corrompues
        from models.database_models import Event

        events = list(Event.select().where(Event.guild == guild))
        for event in events:
            assert event.title is not None
            assert event.guild_id == guild.guild_id
            assert event.interval_minutes > 0

class TestLoadAndStressScenarios:
    """Tests de charge et de stress."""

    @pytest.mark.functional
    @pytest.mark.slow
    @pytest.mark.asyncio
    async def test_multiple_guilds_high_activity(self, working_database, fixture_manager, discord_mock_manager):
        """
        Test de charge avec plusieurs guilds tr√®s actifs.
        
        Sc√©nario : 5 guilds avec beaucoup d'√©v√©nements et d'utilisateurs
        interagissant simultan√©ment.
        """
        guild_count = 5
        users_per_guild = 15
        events_per_guild = 8

        # Cr√©er les guilds et leur contenu
        guilds_data = []
        all_events = []

        for i in range(guild_count):
            guild, users = fixture_manager.create_guild_with_users(
                user_count=users_per_guild,
                name=f"High Activity Guild {i+1}",
                member_count=random.randint(100, 500),
            )

            # Cr√©er plusieurs √©v√©nements par guild
            guild_events = []
            for j in range(events_per_guild):
                event = fixture_manager.create_event(
                    guild=guild,
                    title=f"Event {j+1} in Guild {i+1}",
                    interval_minutes=random.choice([30, 60, 120, 240]),
                )
                guild_events.append(event)

                # Ajouter des r√©actions al√©atoires
                reaction_count = random.randint(3, len(users))
                selected_users = random.sample(users, reaction_count)
                for user in selected_users:
                    fixture_manager.create_reaction(
                        event=event,
                        user=user,
                        emoji=random.choice(["‚úÖ", "‚ùå", "ü§î", "‚≠ê"]),
                    )

            guilds_data.append((guild, users, guild_events))
            all_events.extend(guild_events)

        # Test de performance : v√©rifier que les requ√™tes restent rapides
        start_time = datetime.now()

        # Simuler des requ√™tes simultan√©es de listing
        mock_bot = discord_mock_manager.create_bot_mock()
        from commands.slash_commands import SlashCommands

        slash_commands = SlashCommands(mock_bot)

        async def list_events_for_guild(guild_data):
            guild, users, events = guild_data
            mock_guild = discord_mock_manager.create_guild_mock(
                id=guild.guild_id, name=guild.name
            )
            mock_interaction = Mock()
            mock_interaction.response = AsyncMock()
            mock_interaction.followup = AsyncMock()
            mock_interaction.guild = mock_guild
            mock_interaction.user = discord_mock_manager.create_user_mock(id=users[0].user_id)

            await slash_commands.list_events.callback(slash_commands, mock_interaction)
            return True

        # Ex√©cuter toutes les requ√™tes en parall√®le
        tasks = [list_events_for_guild(guild_data) for guild_data in guilds_data]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Mesurer le temps de r√©ponse
        elapsed = (datetime.now() - start_time).total_seconds()

        # V√©rifier les r√©sultats
        successful_queries = sum(1 for r in results if r is True)
        assert successful_queries == guild_count

        # V√©rifier que les performances restent acceptables (< 10 secondes pour tout)
        assert elapsed < 10.0, f"Les requ√™tes ont pris trop de temps: {elapsed}s"

        # V√©rifier l'int√©grit√© des donn√©es apr√®s la charge
        from models.database_models import Event, Guild, Reaction

        total_events = Event.select().count()
        total_reactions = Reaction.select().count()
        total_guilds = Guild.select().count()

        assert total_events == guild_count * events_per_guild
        assert total_guilds >= guild_count
        assert total_reactions > 0

        logger.info(
            f"Load test completed: {total_guilds} guilds, "
            f"{total_events} events, {total_reactions} reactions in {elapsed:.2f}s"
        )

    @pytest.mark.functional
    @pytest.mark.slow
    @pytest.mark.asyncio
    async def test_reminder_system_under_load(self, working_database, fixture_manager, discord_mock_manager):
        """
        Test du syst√®me de rappels sous charge.
        
        Sc√©nario : Beaucoup d'√©v√©nements n√©cessitent des rappels simultan√©ment.
        """
        # Cr√©er 3 guilds avec plusieurs √©v√©nements n√©cessitant des rappels
        guilds_data = []
        due_events = []

        for i in range(3):
            guild, users = fixture_manager.create_guild_with_users(
                user_count=8, name=f"Reminder Test Guild {i+1}"
            )

            # Cr√©er des √©v√©nements qui n√©cessitent des rappels
            for j in range(10):
                event = fixture_manager.create_event(
                    guild=guild,
                    title=f"Urgent Event {j+1}",
                    interval_minutes=60,
                )

                # Simuler que ces √©v√©nements n√©cessitent des rappels
                event.last_reminder = datetime.now() - timedelta(hours=2)
                event.save()
                due_events.append(event)

                # Ajouter quelques r√©actions pour rendre plus r√©aliste
                for user in random.sample(users, random.randint(2, 5)):
                    fixture_manager.create_reaction(event=event, user=user)

            guilds_data.append((guild, users))

        # Tester le syst√®me de rappels
        from utils.reminder_manager import reminder_manager

        start_time = datetime.now()

        # Ex√©cuter la v√©rification des rappels
        due_events = await reminder_manager.get_due_events()
        reminders_sent = len(due_events)  # Simplification pour le test

        elapsed = (datetime.now() - start_time).total_seconds()

        # V√©rifier que des rappels ont √©t√© trait√©s
        assert reminders_sent > 0, "Des rappels auraient d√ª √™tre envoy√©s"

        # V√©rifier que le traitement reste rapide m√™me avec beaucoup d'√©v√©nements
        assert elapsed < 30.0, f"Le traitement des rappels a pris trop de temps: {elapsed}s"

        # V√©rifier que les √©v√©nements ont √©t√© mis √† jour
        updated_events = 0
        for event in due_events:
            # Recharger l'√©v√©nement depuis la base
            from models.database_models import Event
            event = Event.get_by_id(event.id)
            if event.last_reminder > start_time - timedelta(seconds=5):
                updated_events += 1

        assert updated_events > 0, "Certains √©v√©nements auraient d√ª √™tre mis √† jour"

        logger.info(
            f"Reminder system test: {reminders_sent} reminders processed "
            f"in {elapsed:.2f}s from {len(due_events)} events"
        )

class TestEdgeCasesAndCornerScenarios:
    """Tests des cas limites et sc√©narios particuliers."""

    @pytest.mark.functional
    @pytest.mark.asyncio
    async def test_empty_guild_scenarios(self, working_database, fixture_manager, discord_mock_manager):
        """
        Test des sc√©narios avec guilds vides ou sans activit√©.
        """
        # Cr√©er un guild sans √©v√©nements
        empty_guild = fixture_manager.create_guild(name="Empty Guild")

        mock_bot = discord_mock_manager.create_bot_mock()
        from commands.slash_commands import SlashCommands

        slash_commands = SlashCommands(mock_bot)

        mock_guild = discord_mock_manager.create_guild_mock(
            guild_id=empty_guild.guild_id, name=empty_guild.name
        )
        mock_user = discord_mock_manager.create_user_mock(id=fixture_manager.get_unique_id("user"))
        mock_interaction = Mock()
        mock_interaction.response = AsyncMock()
        mock_interaction.followup = AsyncMock()
        mock_interaction.guild = mock_guild
        mock_interaction.user = mock_user

        # Tester les commandes sur un guild vide
        await slash_commands.list_events.callback(slash_commands, mock_interaction)

        # V√©rifier que la r√©ponse indique qu'il n'y a pas d'√©v√©nements
        mock_interaction.response.send_message.assert_called()
        response = str(mock_interaction.response.send_message.call_args)
        # V√©rifier que la r√©ponse contient un embed et qu'il indique qu'il n'y a pas d'√©v√©nements
        assert "embed=" in response.lower(), "La r√©ponse devrait contenir un embed"
        # V√©rifier que le message n'indique pas d'erreur
        assert "error" not in response.lower() and "erreur" not in response.lower(), "La r√©ponse ne devrait pas contenir d'erreur"

    @pytest.mark.functional
    @pytest.mark.asyncio
    async def test_rapid_state_changes(self, working_database, fixture_manager, discord_mock_manager):
        """
        Test des changements d'√©tat rapides (pause/reprise multiples).
        """
        guild, users = fixture_manager.create_guild_with_users(user_count=2)
        event = fixture_manager.create_event(guild=guild, title="State Change Test")

        mock_bot = discord_mock_manager.create_bot_mock()
        from commands.slash_commands import SlashCommands

        slash_commands = SlashCommands(mock_bot)

        mock_guild = discord_mock_manager.create_guild_mock(
            guild_id=guild.guild_id, name=guild.name
        )
        mock_interaction = Mock()
        mock_interaction.response = AsyncMock()
        mock_interaction.followup = AsyncMock()
        mock_interaction.guild = mock_guild
        mock_interaction.user = discord_mock_manager.create_user_mock(id=users[0].user_id)

        # Effectuer plusieurs changements d'√©tat rapidement
        for i in range(5):
            await slash_commands.pause.callback(slash_commands, mock_interaction, message=f"https://discord.com/channels/{guild.guild_id}/{event.channel_id}/{event.message_id}")
            await slash_commands.resume.callback(slash_commands, mock_interaction, message=f"https://discord.com/channels/{guild.guild_id}/{event.channel_id}/{event.message_id}")

        # V√©rifier l'√©tat final
        from models.database_models import Event

        final_event = Event.get_by_id(event.id)
        assert not final_event.is_paused, "L'√©v√©nement devrait √™tre actif apr√®s les cycles pause/reprise"

    @pytest.mark.functional
    @pytest.mark.asyncio
    async def test_data_consistency_across_operations(self, working_database, fixture_manager, discord_mock_manager):
        """
        Test de la coh√©rence des donn√©es √† travers diff√©rentes op√©rations.
        """
        # Cr√©er un environnement complexe
        guild, users = fixture_manager.create_guild_with_users(user_count=5)
        events = []

        for i in range(3):
            event = fixture_manager.create_event(
                guild=guild, title=f"Consistency Test Event {i+1}"
            )
            events.append(event)

            # Ajouter des r√©actions
            for user in users:
                if random.random() > 0.3:  # 70% de chance de r√©action
                    fixture_manager.create_reaction(event=event, user=user)

        # Capturer l'√©tat initial
        from models.database_models import Event, Reaction

        initial_event_count = Event.select().where(Event.guild == guild).count()
        initial_reaction_count = (
            Reaction.select()
            .join(Event)
            .where(Event.guild == guild)
            .count()
        )

        # Effectuer diverses op√©rations
        mock_bot = discord_mock_manager.create_bot_mock()
        from commands.slash_commands import SlashCommands

        slash_commands = SlashCommands(mock_bot)

        mock_guild = discord_mock_manager.create_guild_mock(
            guild_id=guild.guild_id, name=guild.name
        )
        mock_interaction = Mock()
        mock_interaction.response = AsyncMock()
        mock_interaction.followup = AsyncMock()
        mock_interaction.guild = mock_guild
        mock_interaction.user = discord_mock_manager.create_user_mock(id=users[0].user_id)

        # Pause/reprise d'√©v√©nements
        for event in events[:2]:
            await slash_commands.pause.callback(slash_commands, mock_interaction, message=f"https://discord.com/channels/{guild.guild_id}/{event.channel_id}/{event.message_id}")

        # Ajouter plus de r√©actions
        for event in events:
            for user in random.sample(users, 2):
                try:
                    fixture_manager.create_reaction(event=event, user=user, emoji="üéØ")
                except Exception:
                    # Ignorer les doublons
                    pass

        # Reprendre les √©v√©nements
        for event in events[:2]:
            await slash_commands.resume.callback(slash_commands, mock_interaction, message=f"https://discord.com/channels/{guild.guild_id}/{event.channel_id}/{event.message_id}")

        # V√©rifier la coh√©rence finale
        final_event_count = Event.select().where(Event.guild == guild).count()
        final_reaction_count = (
            Reaction.select()
            .join(Event)
            .where(Event.guild == guild)
            .count()
        )

        # Les √©v√©nements ne devraient pas avoir √©t√© supprim√©s
        assert final_event_count == initial_event_count

        # Les r√©actions devraient avoir augment√©
        assert final_reaction_count > initial_reaction_count

        # V√©rifier que toutes les relations sont intactes
        for event in Event.select().where(Event.guild == guild):
            assert event.guild.guild_id == guild.guild_id
            assert event.title is not None
            assert event.interval_minutes > 0

            # V√©rifier les r√©actions associ√©es
            event_reactions = list(event.reactions)
            for reaction in event_reactions:
                assert reaction.event.id == event.id
                assert reaction.user_id is not None
                assert reaction.emoji is not None


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])